# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CgrF6T7aLQtHPJYBXp3vyS9bwunOCpPu
"""

# Load libraries
import numpy as np
import pandas as pd

# Load data
df = pd.read_csv('/content/winequality-red.csv', sep=';')

# Top and bottom 3 rows
print("Top 3 rows:")
display(df.head(3))
print("\nBottom 3 rows:")
display(df.tail(3))

# Memory usage
print("\nMemory usage before optimization:")
print(df.memory_usage(deep=True).sum() / 1024**2)

# Optimize by changing column dtypes if needed
# Check data types
print("\nData types before optimization:")
print(df.dtypes)

# All columns are float64, let's see if we can downcast
for col in df.columns:
    if df[col].dtype == 'float64':
        df[col] = pd.to_numeric(df[col], downcast='float')

print("\nData types after optimization:")
print(df.dtypes)

print("\nMemory usage after optimization:")
print(df.memory_usage(deep=True).sum() / 1024**2)

# Remove exact duplicates
initial_rows = len(df)
df.drop_duplicates(inplace=True)
print(f"\nRemoved {initial_rows - len(df)} exact duplicates.")

# Remove rows with >3 columns more than 1 std below mean
numeric_cols = df.select_dtypes(include=np.number).columns
means = df[numeric_cols].mean()
stds = df[numeric_cols].std()
lower_bound = means - stds

rows_to_remove = df[numeric_cols] < lower_bound
rows_to_remove = rows_to_remove.sum(axis=1) > 3
df = df[~rows_to_remove].copy()
print(f"Removed {rows_to_remove.sum()} rows with more than 3 columns >1 std below mean.")


# Create new features
df['alcohol_pH_ratio'] = df['alcohol'] / df['pH']
df['residual_sugar_density'] = df['residual sugar'] / df['density']
print("\nCreated new features:")


# Cap chlorides and volatile acidity at 99th percentile
for col in ['chlorides', 'volatile acidity']:
    percentile_99 = df[col].quantile(0.99)
    df[col] = np.where(df[col] > percentile_99, percentile_99, df[col])
print(f"Capped '{col}' at its 99th percentile.")

print("\nData Wrangling Complete. Displaying first 5 rows of the processed DataFrame:")
display(df.head())

# Bin quality
df['quality_group'] = pd.cut(df['quality'], bins=[0, 4, 6, 10], labels=['Low', 'Medium', 'High'], right=True)
print("Binned 'quality' into 'Low', 'Medium', and 'High' groups.")


# Group statistics
grouped_stats = df.groupby('quality_group').agg(
    alcohol_mean=('alcohol', 'mean'),
    alcohol_std=('alcohol', 'std'),
    alcohol_iqr=('alcohol', lambda x: x.quantile(0.75) - x.quantile(0.25)),
    sulphates_mean=('sulphates', 'mean'),
    sulphates_std=('sulphates', 'std'),
    sulphates_iqr=('sulphates', lambda x: x.quantile(0.75) - x.quantile(0.25)),
    citric_acid_mean=('citric acid', 'mean'),
    citric_acid_std=('citric acid', 'std'),
    citric_acid_iqr=('citric acid', lambda x: x.quantile(0.75) - x.quantile(0.25))
)
print("\nGrouped Statistics (Mean, Std, IQR) for 'alcohol', 'sulphates', and 'citric acid' by 'quality_group':")
display(grouped_stats)


# Mean diff between high and low
mean_alcohol_high = df[df['quality_group'] == 'High']['alcohol'].mean()
mean_alcohol_low = df[df['quality_group'] == 'Low']['alcohol'].mean()
mean_volatile_acidity_high = df[df['quality_group'] == 'High']['volatile acidity'].mean()
mean_volatile_acidity_low = df[df['quality_group'] == 'Low']['volatile acidity'].mean()

alcohol_mean_diff = mean_alcohol_high - mean_alcohol_low
volatile_acidity_mean_diff = mean_volatile_acidity_high - mean_volatile_acidity_low

print(f"\nMean difference in alcohol between High and Low quality wines: {alcohol_mean_diff:.4f}")
print(f"Mean difference in volatile acidity between High and Low quality wines: {volatile_acidity_mean_diff:.4f}")


# Multi-index pivot
df['alcohol_quantile'] = pd.qcut(df['alcohol'], q=4, labels=['Q1', 'Q2', 'Q3', 'Q4'])

pivot_table_density = df.pivot_table(
    index='quality_group',
    columns='alcohol_quantile',
    values='density',
    aggfunc='mean'
)
print("\nMulti-index Pivot Table (Mean Density by Quality Group and Alcohol Quantile):")
display(pivot_table_density)

import seaborn as sns
import matplotlib.pyplot as plt

# KDE plots by group
plt.figure(figsize=(10, 6))
sns.kdeplot(data=df, x='alcohol', hue='quality_group', fill=True, common_norm=False)
plt.title('KDE Plot of Alcohol by Quality Group')
plt.xlabel('Alcohol')
plt.ylabel('Density')
plt.show()

# Violin plot for residual sugar by quality_group and pH bins
df['pH_bin'] = pd.cut(df['pH'], bins=4, labels=['Low', 'Medium-Low', 'Medium-High', 'High'])
plt.figure(figsize=(12, 8))
sns.violinplot(data=df, x='quality_group', y='residual sugar', hue='pH_bin', split=True, inner='quart', palette='muted')
plt.title('Violin Plot of Residual Sugar by Quality Group and pH Bin')
plt.xlabel('Quality Group')
plt.ylabel('Residual Sugar')
plt.show()

# Correlation heatmaps
# Calculate correlations
corr_pearson = df.corr(method='pearson', numeric_only=True)
corr_spearman = df.corr(method='spearman', numeric_only=True)

# Sort by correlation with quality
corr_pearson_sorted = corr_pearson.sort_values(by='quality', ascending=False)
corr_spearman_sorted = corr_spearman.sort_values(by='quality', ascending=False)

fig, axes = plt.subplots(1, 2, figsize=(18, 8))

sns.heatmap(corr_pearson_sorted, annot=True, cmap='coolwarm', fmt=".2f", ax=axes[0], cbar=False)
axes[0].set_title('Pearson Correlation Matrix (Sorted by Quality)')

sns.heatmap(corr_spearman_sorted, annot=True, cmap='coolwarm', fmt=".2f", ax=axes[1])
axes[1].set_title('Spearman Correlation Matrix (Sorted by Quality)')

plt.tight_layout()
plt.show()

# Diverging bar chart
# Calculate mean of selected features by quality level
mean_features_by_quality = df.groupby('quality')[['alcohol', 'citric acid', 'density']].mean()

# Calculate Z-scores
mean_z_scores = mean_features_by_quality.apply(lambda x: (x - x.mean()) / x.std(), axis=0)

# Prepare data for plotting
mean_z_scores_melted = mean_z_scores.reset_index().melt('quality', var_name='feature', value_name='z_score')

plt.figure(figsize=(12, 7))
sns.barplot(data=mean_z_scores_melted, x='quality', y='z_score', hue='feature', palette='viridis')
plt.axhline(0, color='grey', lw=1)
plt.title('Z-scores of Mean Alcohol, Citric Acid, and Density by Quality Level')
plt.xlabel('Quality Level')
plt.ylabel('Z-score of Mean')
plt.show()

# Outlier detection on 'total sulfur dioxide'

# IQR method
Q1 = df['total sulfur dioxide'].quantile(0.25)
Q3 = df['total sulfur dioxide'].quantile(0.75)
IQR = Q3 - Q1
iqr_lower_bound = Q1 - 1.5 * IQR
iqr_upper_bound = Q3 + 1.5 * IQR
iqr_outliers = set(df[(df['total sulfur dioxide'] < iqr_lower_bound) | (df['total sulfur dioxide'] > iqr_upper_bound)].index)
print(f"IQR method detected {len(iqr_outliers)} outliers.")

# Z-score method
from scipy.stats import zscore
z_scores = np.abs(zscore(df['total sulfur dioxide']))
zscore_outliers = set(df[z_scores > 3].index) # Using a threshold of 3
print(f"Z-score method detected {len(zscore_outliers)} outliers.")

# MAD (Median Absolute Deviation)
median = df['total sulfur dioxide'].median()
mad = np.median(np.abs(df['total sulfur dioxide'] - median))
mad_threshold = 3 * mad # Using a threshold of 3
mad_outliers = set(df[np.abs(df['total sulfur dioxide'] - median) > mad_threshold].index)
print(f"MAD method detected {len(mad_outliers)} outliers.")

# Compare outliers
print("\nOutlier comparison:")
print(f"IQR only: {len(iqr_outliers - zscore_outliers - mad_outliers)}")
print(f"Z-score only: {len(zscore_outliers - iqr_outliers - mad_outliers)}")
print(f"MAD only: {len(mad_outliers - iqr_outliers - zscore_outliers)}")
print(f"IQR and Z-score: {len(iqr_outliers.intersection(zscore_outliers) - mad_outliers)}")
print(f"IQR and MAD: {len(iqr_outliers.intersection(mad_outliers) - zscore_outliers)}")
print(f"Z-score and MAD: {len(zscore_outliers.intersection(mad_outliers) - iqr_outliers)}")
print(f"All three methods: {len(iqr_outliers.intersection(zscore_outliers).intersection(mad_outliers))}")

# Remove the most extreme outliers (intersection of all methods)
extreme_outliers = iqr_outliers.intersection(zscore_outliers).intersection(mad_outliers)
df_before_removal = df.copy()
df_after_removal = df.drop(extreme_outliers)
print(f"\nRemoved {len(extreme_outliers)} extreme outliers (intersection of all methods).")

# Compare group-wise means before and after removal
print("\nComparison of group-wise means before and after removing extreme outliers:")
display(df_before_removal.groupby('quality_group')[['total sulfur dioxide']].mean())
display(df_after_removal.groupby('quality_group')[['total sulfur dioxide']].mean())

import time
import functools
import matplotlib.pyplot as plt
import seaborn as sns

# Feature stats function
def feature_stats(df, col):
    """
    Calculates skewness, kurtosis, 95th percentile, and missing percentage for a column.

    Args:
        df (pd.DataFrame): The input DataFrame.
        col (str): The column name.

    Returns:
        dict: A dictionary containing the calculated statistics.
    """
    if col not in df.columns:
        return {"error": f"Column '{col}' not found in DataFrame."}

    skewness = df[col].skew()
    kurtosis = df[col].kurtosis()
    percentile_95 = df[col].quantile(0.95)
    missing_percentage = df[col].isnull().mean() * 100

    return {
        "skewness": skewness,
        "kurtosis": kurtosis,
        "95th_percentile": percentile_95,
        "missing_percentage": missing_percentage
    }

# Decorator for timing
def timeit(func):
    """
    Decorator to measure the execution time of a function.
    """
    @functools.wraps(func)
    def wrapper_timer(*args, **kwargs):
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Execution of '{func.__name__}' took {run_time:.4f} seconds")
        return value
    return wrapper_timer

# Dashboard
@timeit # Apply the decorator to the dashboard function
def create_dashboard(df):
    """
    Creates a dashboard with subplots for visualizing key insights.
    """
    fig, axes = plt.subplots(2, 2, figsize=(18, 15))
    fig.suptitle('Wine Quality Advanced EDA Dashboard', fontsize=20)

    # Histograms of top 3 correlated features with quality

    corr_pearson = df.corr(method='pearson', numeric_only=True)
    quality_correlations = corr_pearson['quality'].abs().sort_values(ascending=False)
    top_3_correlated_features = quality_correlations.index[1:4] # Exclude quality itself

    for i, feature in enumerate(top_3_correlated_features):
        sns.histplot(data=df, x=feature, ax=axes[0, i], kde=True)
        axes[0, i].set_title(f'Distribution of {feature}')

    # A single pairplot of only High and Low quality wines with citric acid, alcohol, and pH
    high_low_quality_df = df[df['quality_group'].isin(['High', 'Low'])].copy()
    selected_features = ['citric acid', 'alcohol', 'pH', 'quality_group']


    # Clear the last subplot area if needed or just show the pairplot separately
    fig.delaxes(axes[1, 1]) # Remove the empty subplot to avoid overlapping

    # Create the pairplot separately
    pairplot_fig = sns.pairplot(high_low_quality_df[selected_features], hue='quality_group', palette='viridis')
    pairplot_fig.fig.suptitle('Pairplot of High vs Low Quality Wines (Citric Acid, Alcohol, pH)', y=1.02)
    plt.show() # Display the pairplot figure


    plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust layout to make space for suptitle
    plt.show()

